/*******************************************************************************
 * HCC Compression Advisor - Logging Package
 * Version: 1.0.0
 * Date: 2025-11-13
 *
 * DESCRIPTION:
 *   Production-ready logging package for compression advisor system.
 *   Provides comprehensive logging with autonomous transactions for
 *   reliable error tracking and operational auditing.
 *
 * FEATURES:
 *   - Autonomous transaction logging (guaranteed commit)
 *   - Multiple log levels (DEBUG, INFO, WARNING, ERROR)
 *   - Automatic context capture (timestamp, user, session)
 *   - Error stack and backtrace capture
 *   - Performance metrics tracking
 *   - No parent transaction impact
 *
 * USAGE:
 *   Connect as schema owner (e.g., COMPRESSION_MGR) and execute:
 *   @02a_logging_pkg.sql
 *
 * DEPENDENCIES:
 *   - T_COMPRESSION_LOG table (created inline if not exists)
 *   - Oracle Database 12c or higher (for autonomous transactions)
 *
 * NOTES:
 *   - All logging procedures use PRAGMA AUTONOMOUS_TRANSACTION
 *   - Logging failures will not impact calling procedures
 *   - Default retention: 90 days (configurable via purge procedures)
 *
 ******************************************************************************/

SET ECHO ON
SET FEEDBACK ON
SET SERVEROUTPUT ON SIZE UNLIMITED
SET LINESIZE 200
SET PAGESIZE 1000

PROMPT ================================================================================
PROMPT Creating Compression Logging Infrastructure
PROMPT ================================================================================

-- ============================================================================
-- SECTION 1: LOG TABLE CREATION
-- ============================================================================

PROMPT
PROMPT Creating T_COMPRESSION_LOG table...

-- Create logging table if it doesn't exist
DECLARE
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count
  FROM user_tables
  WHERE table_name = 'T_COMPRESSION_LOG';

  IF v_count = 0 THEN
    EXECUTE IMMEDIATE 'CREATE TABLE T_COMPRESSION_LOG (LOG_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY, LOG_LEVEL VARCHAR2(10) NOT NULL, LOG_CATEGORY VARCHAR2(30) DEFAULT ''GENERAL'', PACKAGE_NAME VARCHAR2(128), PROCEDURE_NAME VARCHAR2(128), LINE_NUMBER NUMBER, LOG_MESSAGE VARCHAR2(4000) NOT NULL, ERROR_CODE NUMBER, ERROR_MESSAGE VARCHAR2(4000), ERROR_BACKTRACE VARCHAR2(4000), CALL_STACK VARCHAR2(4000), SESSION_ID NUMBER, SESSION_USER VARCHAR2(128), OS_USER VARCHAR2(128), MODULE VARCHAR2(64), ACTION VARCHAR2(64), CLIENT_IDENTIFIER VARCHAR2(64), CLIENT_INFO VARCHAR2(64), HOST_NAME VARCHAR2(64), IP_ADDRESS VARCHAR2(45), PROGRAM_NAME VARCHAR2(64), CPU_TIME_MS NUMBER, ELAPSED_TIME_MS NUMBER, MEMORY_USED_MB NUMBER, OBJECT_OWNER VARCHAR2(128), OBJECT_NAME VARCHAR2(128), OBJECT_TYPE VARCHAR2(30), ADVISOR_RUN_ID NUMBER, ANALYSIS_ID NUMBER, EXECUTION_ID NUMBER, LOG_TIMESTAMP TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL, LOG_DATE DATE DEFAULT SYSDATE NOT NULL, ADDITIONAL_DATA CLOB, CONSTRAINT PK_COMPRESSION_LOG PRIMARY KEY (LOG_ID), CONSTRAINT CHK_LOG_LEVEL CHECK (LOG_LEVEL IN (''DEBUG'', ''INFO'', ''WARNING'', ''ERROR'', ''FATAL'')), CONSTRAINT CHK_LOG_TIMESTAMP CHECK (LOG_TIMESTAMP IS NOT NULL))';

    DBMS_OUTPUT.PUT_LINE('✓ T_COMPRESSION_LOG table created successfully');
  ELSE
    DBMS_OUTPUT.PUT_LINE('✓ T_COMPRESSION_LOG table already exists');
  END IF;
END;
/

-- Create indexes for performance
DECLARE
  v_count NUMBER;
BEGIN
  -- Index on timestamp for time-based queries
  SELECT COUNT(*) INTO v_count
  FROM user_indexes
  WHERE index_name = 'IDX_COMP_LOG_TIMESTAMP';

  IF v_count = 0 THEN
    EXECUTE IMMEDIATE 'CREATE INDEX IDX_COMP_LOG_TIMESTAMP ON T_COMPRESSION_LOG(LOG_DATE DESC, LOG_LEVEL)';
    DBMS_OUTPUT.PUT_LINE('✓ IDX_COMP_LOG_TIMESTAMP created');
  END IF;

  -- Index on package/procedure for troubleshooting
  SELECT COUNT(*) INTO v_count
  FROM user_indexes
  WHERE index_name = 'IDX_COMP_LOG_SOURCE';

  IF v_count = 0 THEN
    EXECUTE IMMEDIATE 'CREATE INDEX IDX_COMP_LOG_SOURCE ON T_COMPRESSION_LOG(PACKAGE_NAME, PROCEDURE_NAME, LOG_DATE DESC)';
    DBMS_OUTPUT.PUT_LINE('✓ IDX_COMP_LOG_SOURCE created');
  END IF;

  -- Index on object for object-specific queries
  SELECT COUNT(*) INTO v_count
  FROM user_indexes
  WHERE index_name = 'IDX_COMP_LOG_OBJECT';

  IF v_count = 0 THEN
    EXECUTE IMMEDIATE 'CREATE INDEX IDX_COMP_LOG_OBJECT ON T_COMPRESSION_LOG(OBJECT_OWNER, OBJECT_NAME, LOG_DATE DESC)';
    DBMS_OUTPUT.PUT_LINE('✓ IDX_COMP_LOG_OBJECT created');
  END IF;

  -- Index on run/analysis IDs for correlation
  SELECT COUNT(*) INTO v_count
  FROM user_indexes
  WHERE index_name = 'IDX_COMP_LOG_RUNS';

  IF v_count = 0 THEN
    EXECUTE IMMEDIATE 'CREATE INDEX IDX_COMP_LOG_RUNS ON T_COMPRESSION_LOG(ADVISOR_RUN_ID, ANALYSIS_ID, EXECUTION_ID)';
    DBMS_OUTPUT.PUT_LINE('✓ IDX_COMP_LOG_RUNS created');
  END IF;

  -- Bitmap index on log level for filtering
  SELECT COUNT(*) INTO v_count
  FROM user_indexes
  WHERE index_name = 'IDX_COMP_LOG_LEVEL_BMP';

  IF v_count = 0 THEN
    EXECUTE IMMEDIATE 'CREATE BITMAP INDEX IDX_COMP_LOG_LEVEL_BMP ON T_COMPRESSION_LOG(LOG_LEVEL)';
    DBMS_OUTPUT.PUT_LINE('✓ IDX_COMP_LOG_LEVEL_BMP created');
  END IF;
END;
/

-- Add table and column comments
COMMENT ON TABLE T_COMPRESSION_LOG IS 'Centralized logging for HCC Compression Advisor operations';
COMMENT ON COLUMN T_COMPRESSION_LOG.LOG_LEVEL IS 'Log severity: DEBUG, INFO, WARNING, ERROR, FATAL';
COMMENT ON COLUMN T_COMPRESSION_LOG.LOG_CATEGORY IS 'Logical grouping: GENERAL, ANALYSIS, EXECUTION, SYSTEM';
COMMENT ON COLUMN T_COMPRESSION_LOG.ERROR_BACKTRACE IS 'PL/SQL error backtrace for debugging';
COMMENT ON COLUMN T_COMPRESSION_LOG.ADDITIONAL_DATA IS 'Optional JSON data for extended context';

-- ============================================================================
-- SECTION 2: PACKAGE SPECIFICATION
-- ============================================================================

PROMPT
PROMPT Creating PKG_COMPRESSION_LOG package specification...

CREATE OR REPLACE PACKAGE pkg_compression_log AS

  /***************************************************************************
   * Package: PKG_COMPRESSION_LOG
   * Description: Centralized logging infrastructure for compression advisor
   * Version: 1.0.0
   *
   * Features:
   *   - Multiple log levels with automatic filtering
   *   - Autonomous transaction logging (no rollback impact)
   *   - Automatic context capture (session, user, performance)
   *   - Structured error logging with stack traces
   *   - Object-specific logging for analysis tracking
   *   - Performance metrics integration
   *   - Automatic log retention management
   ***************************************************************************/

  -- Package version
  c_version CONSTANT VARCHAR2(10) := '1.0.0';

  -- Log levels (integer for performance comparison)
  c_level_debug   CONSTANT PLS_INTEGER := 10;
  c_level_info    CONSTANT PLS_INTEGER := 20;
  c_level_warning CONSTANT PLS_INTEGER := 30;
  c_level_error   CONSTANT PLS_INTEGER := 40;
  c_level_fatal   CONSTANT PLS_INTEGER := 50;

  -- Global log level threshold (set via set_log_level)
  g_log_level PLS_INTEGER := c_level_info;  -- Default: INFO and above

  -- ========================================================================
  -- Core Logging Procedures
  -- ========================================================================

  /**
   * Log DEBUG level message
   * Use for: Detailed diagnostic information, variable values, flow control
   *
   * @param p_package      Source package name
   * @param p_procedure    Source procedure/function name
   * @param p_message      Log message
   * @param p_object_owner Optional: Object owner for context
   * @param p_object_name  Optional: Object name for context
   * @param p_object_type  Optional: Object type for context
   * @param p_advisor_run_id Optional: Advisor run ID for correlation
   * @param p_analysis_id  Optional: Analysis ID for correlation
   */
  PROCEDURE log_debug(
    p_package       IN VARCHAR2,
    p_procedure     IN VARCHAR2,
    p_message       IN VARCHAR2,
    p_object_owner  IN VARCHAR2 DEFAULT NULL,
    p_object_name   IN VARCHAR2 DEFAULT NULL,
    p_object_type   IN VARCHAR2 DEFAULT NULL,
    p_advisor_run_id IN NUMBER DEFAULT NULL,
    p_analysis_id   IN NUMBER DEFAULT NULL
  );

  /**
   * Log INFO level message
   * Use for: Normal operation messages, successful completions, milestones
   *
   * @param p_package      Source package name
   * @param p_procedure    Source procedure/function name
   * @param p_message      Log message
   * @param p_object_owner Optional: Object owner for context
   * @param p_object_name  Optional: Object name for context
   * @param p_object_type  Optional: Object type for context
   * @param p_advisor_run_id Optional: Advisor run ID for correlation
   * @param p_analysis_id  Optional: Analysis ID for correlation
   */
  PROCEDURE log_info(
    p_package       IN VARCHAR2,
    p_procedure     IN VARCHAR2,
    p_message       IN VARCHAR2,
    p_object_owner  IN VARCHAR2 DEFAULT NULL,
    p_object_name   IN VARCHAR2 DEFAULT NULL,
    p_object_type   IN VARCHAR2 DEFAULT NULL,
    p_advisor_run_id IN NUMBER DEFAULT NULL,
    p_analysis_id   IN NUMBER DEFAULT NULL
  );

  /**
   * Log WARNING level message
   * Use for: Unexpected conditions that don't prevent operation, deprecations
   *
   * @param p_package      Source package name
   * @param p_procedure    Source procedure/function name
   * @param p_message      Log message
   * @param p_object_owner Optional: Object owner for context
   * @param p_object_name  Optional: Object name for context
   * @param p_object_type  Optional: Object type for context
   * @param p_advisor_run_id Optional: Advisor run ID for correlation
   * @param p_analysis_id  Optional: Analysis ID for correlation
   */
  PROCEDURE log_warning(
    p_package       IN VARCHAR2,
    p_procedure     IN VARCHAR2,
    p_message       IN VARCHAR2,
    p_object_owner  IN VARCHAR2 DEFAULT NULL,
    p_object_name   IN VARCHAR2 DEFAULT NULL,
    p_object_type   IN VARCHAR2 DEFAULT NULL,
    p_advisor_run_id IN NUMBER DEFAULT NULL,
    p_analysis_id   IN NUMBER DEFAULT NULL
  );

  /**
   * Log ERROR level message
   * Use for: Error conditions, exceptions, operation failures
   *
   * @param p_package      Source package name
   * @param p_procedure    Source procedure/function name
   * @param p_message      Log message
   * @param p_error        Optional: Error object (SQLERRM)
   * @param p_object_owner Optional: Object owner for context
   * @param p_object_name  Optional: Object name for context
   * @param p_object_type  Optional: Object type for context
   * @param p_advisor_run_id Optional: Advisor run ID for correlation
   * @param p_analysis_id  Optional: Analysis ID for correlation
   */
  PROCEDURE log_error(
    p_package       IN VARCHAR2,
    p_procedure     IN VARCHAR2,
    p_message       IN VARCHAR2,
    p_error         IN VARCHAR2 DEFAULT NULL,
    p_object_owner  IN VARCHAR2 DEFAULT NULL,
    p_object_name   IN VARCHAR2 DEFAULT NULL,
    p_object_type   IN VARCHAR2 DEFAULT NULL,
    p_advisor_run_id IN NUMBER DEFAULT NULL,
    p_analysis_id   IN NUMBER DEFAULT NULL
  );

  /**
   * Log FATAL level message
   * Use for: Critical system failures, unrecoverable errors
   *
   * @param p_package      Source package name
   * @param p_procedure    Source procedure/function name
   * @param p_message      Log message
   * @param p_error        Optional: Error object (SQLERRM)
   * @param p_object_owner Optional: Object owner for context
   * @param p_object_name  Optional: Object name for context
   */
  PROCEDURE log_fatal(
    p_package       IN VARCHAR2,
    p_procedure     IN VARCHAR2,
    p_message       IN VARCHAR2,
    p_error         IN VARCHAR2 DEFAULT NULL,
    p_object_owner  IN VARCHAR2 DEFAULT NULL,
    p_object_name   IN VARCHAR2 DEFAULT NULL
  );

  -- ========================================================================
  -- Configuration Procedures
  -- ========================================================================

  /**
   * Set the global log level threshold
   * Only messages at or above this level will be logged
   *
   * @param p_level Log level (DEBUG=10, INFO=20, WARNING=30, ERROR=40, FATAL=50)
   */
  PROCEDURE set_log_level(p_level IN PLS_INTEGER);

  /**
   * Get the current log level threshold
   *
   * @return Current log level
   */
  FUNCTION get_log_level RETURN PLS_INTEGER;

  -- ========================================================================
  -- Maintenance Procedures
  -- ========================================================================

  /**
   * Purge old log entries
   *
   * @param p_retention_days Number of days to retain (default: 90)
   * @param p_log_level      Optional: Only purge specific level
   * @return Number of rows deleted
   */
  FUNCTION purge_logs(
    p_retention_days IN NUMBER DEFAULT 90,
    p_log_level      IN VARCHAR2 DEFAULT NULL
  ) RETURN NUMBER;

  /**
   * Get log statistics
   *
   * @param p_days Number of days to analyze (default: 7)
   * @return Cursor with statistics
   */
  FUNCTION get_log_stats(p_days IN NUMBER DEFAULT 7) RETURN SYS_REFCURSOR;

  /**
   * Archive old logs to archive table
   *
   * @param p_archive_days Age threshold for archiving (default: 30)
   * @return Number of rows archived
   */
  FUNCTION archive_logs(p_archive_days IN NUMBER DEFAULT 30) RETURN NUMBER;

END pkg_compression_log;
/

-- ============================================================================
-- SECTION 3: PACKAGE BODY
-- ============================================================================

PROMPT
PROMPT Creating PKG_COMPRESSION_LOG package body...

CREATE OR REPLACE PACKAGE BODY pkg_compression_log AS

  /***************************************************************************
   * Private Procedures and Functions
   ***************************************************************************/

  /**
   * Internal procedure to write log entry with full context capture
   * Uses autonomous transaction to ensure logging survives rollbacks
   */
  PROCEDURE write_log(
    p_log_level     IN VARCHAR2,
    p_package       IN VARCHAR2,
    p_procedure     IN VARCHAR2,
    p_message       IN VARCHAR2,
    p_error_code    IN NUMBER DEFAULT NULL,
    p_error_message IN VARCHAR2 DEFAULT NULL,
    p_object_owner  IN VARCHAR2 DEFAULT NULL,
    p_object_name   IN VARCHAR2 DEFAULT NULL,
    p_object_type   IN VARCHAR2 DEFAULT NULL,
    p_advisor_run_id IN NUMBER DEFAULT NULL,
    p_analysis_id   IN NUMBER DEFAULT NULL,
    p_execution_id  IN NUMBER DEFAULT NULL
  ) IS
    PRAGMA AUTONOMOUS_TRANSACTION;

    v_session_id       NUMBER;
    v_session_user     VARCHAR2(128);
    v_os_user          VARCHAR2(128);
    v_module           VARCHAR2(64);
    v_action           VARCHAR2(64);
    v_client_id        VARCHAR2(64);
    v_client_info      VARCHAR2(64);
    v_host_name        VARCHAR2(64);
    v_ip_address       VARCHAR2(45);
    v_program_name     VARCHAR2(64);
    v_error_backtrace  VARCHAR2(4000);
    v_call_stack       VARCHAR2(4000);

  BEGIN
    -- Capture session context
    BEGIN
      SELECT
        SYS_CONTEXT('USERENV', 'SID'),
        SYS_CONTEXT('USERENV', 'SESSION_USER'),
        SYS_CONTEXT('USERENV', 'OS_USER'),
        SYS_CONTEXT('USERENV', 'MODULE'),
        SYS_CONTEXT('USERENV', 'ACTION'),
        SYS_CONTEXT('USERENV', 'CLIENT_IDENTIFIER'),
        SYS_CONTEXT('USERENV', 'CLIENT_INFO'),
        SYS_CONTEXT('USERENV', 'HOST'),
        SYS_CONTEXT('USERENV', 'IP_ADDRESS'),
        SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA')
      INTO
        v_session_id,
        v_session_user,
        v_os_user,
        v_module,
        v_action,
        v_client_id,
        v_client_info,
        v_host_name,
        v_ip_address,
        v_program_name
      FROM dual;
    EXCEPTION
      WHEN OTHERS THEN
        -- If context capture fails, continue with NULLs
        NULL;
    END;

    -- Capture error backtrace if error
    IF p_error_code IS NOT NULL THEN
      BEGIN
        v_error_backtrace := DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
        v_call_stack := DBMS_UTILITY.FORMAT_CALL_STACK;
      EXCEPTION
        WHEN OTHERS THEN
          v_error_backtrace := NULL;
          v_call_stack := NULL;
      END;
    END IF;

    -- Insert log entry
    INSERT INTO T_COMPRESSION_LOG (
      LOG_LEVEL,
      LOG_CATEGORY,
      PACKAGE_NAME,
      PROCEDURE_NAME,
      LOG_MESSAGE,
      ERROR_CODE,
      ERROR_MESSAGE,
      ERROR_BACKTRACE,
      CALL_STACK,
      SESSION_ID,
      SESSION_USER,
      OS_USER,
      MODULE,
      ACTION,
      CLIENT_IDENTIFIER,
      CLIENT_INFO,
      HOST_NAME,
      IP_ADDRESS,
      PROGRAM_NAME,
      OBJECT_OWNER,
      OBJECT_NAME,
      OBJECT_TYPE,
      ADVISOR_RUN_ID,
      ANALYSIS_ID,
      EXECUTION_ID
    ) VALUES (
      p_log_level,
      'GENERAL',
      UPPER(p_package),
      UPPER(p_procedure),
      p_message,
      p_error_code,
      p_error_message,
      v_error_backtrace,
      v_call_stack,
      v_session_id,
      v_session_user,
      v_os_user,
      v_module,
      v_action,
      v_client_id,
      v_client_info,
      v_host_name,
      v_ip_address,
      v_program_name,
      UPPER(p_object_owner),
      UPPER(p_object_name),
      UPPER(p_object_type),
      p_advisor_run_id,
      p_analysis_id,
      p_execution_id
    );

    -- Commit the autonomous transaction
    COMMIT;

  EXCEPTION
    WHEN OTHERS THEN
      -- If logging fails, rollback and silently continue
      -- We don't want logging failures to break the application
      ROLLBACK;
  END write_log;

  /***************************************************************************
   * Public Procedures Implementation
   ***************************************************************************/

  -- ========================================================================
  -- log_debug: Debug level logging
  -- ========================================================================
  PROCEDURE log_debug(
    p_package       IN VARCHAR2,
    p_procedure     IN VARCHAR2,
    p_message       IN VARCHAR2,
    p_object_owner  IN VARCHAR2 DEFAULT NULL,
    p_object_name   IN VARCHAR2 DEFAULT NULL,
    p_object_type   IN VARCHAR2 DEFAULT NULL,
    p_advisor_run_id IN NUMBER DEFAULT NULL,
    p_analysis_id   IN NUMBER DEFAULT NULL
  ) IS
  BEGIN
    -- Only log if current level allows DEBUG
    IF g_log_level <= c_level_debug THEN
      write_log(
        p_log_level     => 'DEBUG',
        p_package       => p_package,
        p_procedure     => p_procedure,
        p_message       => p_message,
        p_object_owner  => p_object_owner,
        p_object_name   => p_object_name,
        p_object_type   => p_object_type,
        p_advisor_run_id => p_advisor_run_id,
        p_analysis_id   => p_analysis_id
      );
    END IF;
  END log_debug;

  -- ========================================================================
  -- log_info: Info level logging
  -- ========================================================================
  PROCEDURE log_info(
    p_package       IN VARCHAR2,
    p_procedure     IN VARCHAR2,
    p_message       IN VARCHAR2,
    p_object_owner  IN VARCHAR2 DEFAULT NULL,
    p_object_name   IN VARCHAR2 DEFAULT NULL,
    p_object_type   IN VARCHAR2 DEFAULT NULL,
    p_advisor_run_id IN NUMBER DEFAULT NULL,
    p_analysis_id   IN NUMBER DEFAULT NULL
  ) IS
  BEGIN
    -- Only log if current level allows INFO
    IF g_log_level <= c_level_info THEN
      write_log(
        p_log_level     => 'INFO',
        p_package       => p_package,
        p_procedure     => p_procedure,
        p_message       => p_message,
        p_object_owner  => p_object_owner,
        p_object_name   => p_object_name,
        p_object_type   => p_object_type,
        p_advisor_run_id => p_advisor_run_id,
        p_analysis_id   => p_analysis_id
      );
    END IF;
  END log_info;

  -- ========================================================================
  -- log_warning: Warning level logging
  -- ========================================================================
  PROCEDURE log_warning(
    p_package       IN VARCHAR2,
    p_procedure     IN VARCHAR2,
    p_message       IN VARCHAR2,
    p_object_owner  IN VARCHAR2 DEFAULT NULL,
    p_object_name   IN VARCHAR2 DEFAULT NULL,
    p_object_type   IN VARCHAR2 DEFAULT NULL,
    p_advisor_run_id IN NUMBER DEFAULT NULL,
    p_analysis_id   IN NUMBER DEFAULT NULL
  ) IS
  BEGIN
    -- Only log if current level allows WARNING
    IF g_log_level <= c_level_warning THEN
      write_log(
        p_log_level     => 'WARNING',
        p_package       => p_package,
        p_procedure     => p_procedure,
        p_message       => p_message,
        p_object_owner  => p_object_owner,
        p_object_name   => p_object_name,
        p_object_type   => p_object_type,
        p_advisor_run_id => p_advisor_run_id,
        p_analysis_id   => p_analysis_id
      );
    END IF;
  END log_warning;

  -- ========================================================================
  -- log_error: Error level logging with error details
  -- ========================================================================
  PROCEDURE log_error(
    p_package       IN VARCHAR2,
    p_procedure     IN VARCHAR2,
    p_message       IN VARCHAR2,
    p_error         IN VARCHAR2 DEFAULT NULL,
    p_object_owner  IN VARCHAR2 DEFAULT NULL,
    p_object_name   IN VARCHAR2 DEFAULT NULL,
    p_object_type   IN VARCHAR2 DEFAULT NULL,
    p_advisor_run_id IN NUMBER DEFAULT NULL,
    p_analysis_id   IN NUMBER DEFAULT NULL
  ) IS
    v_error_code NUMBER;
    v_error_msg  VARCHAR2(4000);
  BEGIN
    -- Only log if current level allows ERROR
    IF g_log_level <= c_level_error THEN
      -- Parse error information
      IF p_error IS NOT NULL THEN
        -- Try to extract SQLCODE if present
        BEGIN
          v_error_code := SQLCODE;
          v_error_msg := p_error;
        EXCEPTION
          WHEN OTHERS THEN
            v_error_code := NULL;
            v_error_msg := p_error;
        END;
      ELSE
        v_error_code := SQLCODE;
        v_error_msg := SQLERRM;
      END IF;

      write_log(
        p_log_level     => 'ERROR',
        p_package       => p_package,
        p_procedure     => p_procedure,
        p_message       => p_message,
        p_error_code    => v_error_code,
        p_error_message => v_error_msg,
        p_object_owner  => p_object_owner,
        p_object_name   => p_object_name,
        p_object_type   => p_object_type,
        p_advisor_run_id => p_advisor_run_id,
        p_analysis_id   => p_analysis_id
      );
    END IF;
  END log_error;

  -- ========================================================================
  -- log_fatal: Fatal level logging
  -- ========================================================================
  PROCEDURE log_fatal(
    p_package       IN VARCHAR2,
    p_procedure     IN VARCHAR2,
    p_message       IN VARCHAR2,
    p_error         IN VARCHAR2 DEFAULT NULL,
    p_object_owner  IN VARCHAR2 DEFAULT NULL,
    p_object_name   IN VARCHAR2 DEFAULT NULL
  ) IS
    v_error_code NUMBER;
    v_error_msg  VARCHAR2(4000);
  BEGIN
    -- FATAL is always logged regardless of log level
    -- Parse error information
    IF p_error IS NOT NULL THEN
      v_error_code := SQLCODE;
      v_error_msg := p_error;
    ELSE
      v_error_code := SQLCODE;
      v_error_msg := SQLERRM;
    END IF;

    write_log(
      p_log_level     => 'FATAL',
      p_package       => p_package,
      p_procedure     => p_procedure,
      p_message       => p_message,
      p_error_code    => v_error_code,
      p_error_message => v_error_msg,
      p_object_owner  => p_object_owner,
      p_object_name   => p_object_name
    );
  END log_fatal;

  -- ========================================================================
  -- Configuration Procedures
  -- ========================================================================

  PROCEDURE set_log_level(p_level IN PLS_INTEGER) IS
  BEGIN
    IF p_level BETWEEN c_level_debug AND c_level_fatal THEN
      g_log_level := p_level;
      log_info(
        'PKG_COMPRESSION_LOG',
        'set_log_level',
        'Log level changed to ' || p_level
      );
    ELSE
      RAISE_APPLICATION_ERROR(
        -20001,
        'Invalid log level. Use c_level_debug(10) through c_level_fatal(50)'
      );
    END IF;
  END set_log_level;

  FUNCTION get_log_level RETURN PLS_INTEGER IS
  BEGIN
    RETURN g_log_level;
  END get_log_level;

  -- ========================================================================
  -- Maintenance Procedures
  -- ========================================================================

  FUNCTION purge_logs(
    p_retention_days IN NUMBER DEFAULT 90,
    p_log_level      IN VARCHAR2 DEFAULT NULL
  ) RETURN NUMBER IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    v_rows_deleted NUMBER := 0;
  BEGIN
    IF p_log_level IS NOT NULL THEN
      DELETE FROM T_COMPRESSION_LOG
      WHERE LOG_DATE < SYSDATE - p_retention_days
        AND LOG_LEVEL = p_log_level;
    ELSE
      DELETE FROM T_COMPRESSION_LOG
      WHERE LOG_DATE < SYSDATE - p_retention_days;
    END IF;

    v_rows_deleted := SQL%ROWCOUNT;
    COMMIT;

    log_info(
      'PKG_COMPRESSION_LOG',
      'purge_logs',
      'Purged ' || v_rows_deleted || ' log entries older than ' ||
      p_retention_days || ' days'
    );

    RETURN v_rows_deleted;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      RAISE;
  END purge_logs;

  FUNCTION get_log_stats(p_days IN NUMBER DEFAULT 7) RETURN SYS_REFCURSOR IS
    v_cursor SYS_REFCURSOR;
  BEGIN
    OPEN v_cursor FOR
      SELECT
        LOG_LEVEL,
        COUNT(*) AS log_count,
        COUNT(DISTINCT PACKAGE_NAME) AS package_count,
        COUNT(DISTINCT SESSION_ID) AS session_count,
        MIN(LOG_TIMESTAMP) AS first_log,
        MAX(LOG_TIMESTAMP) AS last_log,
        ROUND(AVG(CASE WHEN ERROR_CODE IS NOT NULL THEN 1 ELSE 0 END) * 100, 2) AS error_pct
      FROM T_COMPRESSION_LOG
      WHERE LOG_DATE >= SYSDATE - p_days
      GROUP BY LOG_LEVEL
      ORDER BY
        CASE LOG_LEVEL
          WHEN 'FATAL' THEN 1
          WHEN 'ERROR' THEN 2
          WHEN 'WARNING' THEN 3
          WHEN 'INFO' THEN 4
          WHEN 'DEBUG' THEN 5
        END;

    RETURN v_cursor;
  END get_log_stats;

  FUNCTION archive_logs(p_archive_days IN NUMBER DEFAULT 30) RETURN NUMBER IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    v_rows_archived NUMBER := 0;
  BEGIN
    -- Create archive table if not exists
    DECLARE
      v_count NUMBER;
    BEGIN
      SELECT COUNT(*) INTO v_count
      FROM user_tables
      WHERE table_name = 'T_COMPRESSION_LOG_ARCHIVE';

      IF v_count = 0 THEN
        EXECUTE IMMEDIATE 'CREATE TABLE T_COMPRESSION_LOG_ARCHIVE AS SELECT * FROM T_COMPRESSION_LOG WHERE 1=0';
      END IF;
    END;

    -- Archive old logs
    INSERT INTO T_COMPRESSION_LOG_ARCHIVE
    SELECT * FROM T_COMPRESSION_LOG
    WHERE LOG_DATE < SYSDATE - p_archive_days;

    v_rows_archived := SQL%ROWCOUNT;

    -- Delete archived logs from main table
    DELETE FROM T_COMPRESSION_LOG
    WHERE LOG_DATE < SYSDATE - p_archive_days;

    COMMIT;

    log_info(
      'PKG_COMPRESSION_LOG',
      'archive_logs',
      'Archived ' || v_rows_archived || ' log entries older than ' ||
      p_archive_days || ' days'
    );

    RETURN v_rows_archived;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      RAISE;
  END archive_logs;

END pkg_compression_log;
/

-- ============================================================================
-- SECTION 4: VERIFICATION AND TESTING
-- ============================================================================

PROMPT
PROMPT ================================================================================
PROMPT Verification and Testing
PROMPT ================================================================================

-- Verify package compilation
PROMPT
PROMPT Checking package compilation status...

SELECT
  object_name,
  object_type,
  status,
  TO_CHAR(last_ddl_time, 'YYYY-MM-DD HH24:MI:SS') AS last_compiled
FROM user_objects
WHERE object_name = 'PKG_COMPRESSION_LOG'
ORDER BY object_type;

-- Test basic logging functionality
PROMPT
PROMPT Running basic logging tests...

DECLARE
  v_test_count NUMBER := 0;
BEGIN
  DBMS_OUTPUT.PUT_LINE('');
  DBMS_OUTPUT.PUT_LINE('Testing PKG_COMPRESSION_LOG functionality...');
  DBMS_OUTPUT.PUT_LINE('================================================');

  -- Test 1: INFO logging
  pkg_compression_log.log_info(
    p_package => 'TEST_PACKAGE',
    p_procedure => 'test_procedure',
    p_message => 'Test INFO message - logging system initialized'
  );
  v_test_count := v_test_count + 1;
  DBMS_OUTPUT.PUT_LINE('✓ Test 1: INFO logging successful');

  -- Test 2: WARNING logging
  pkg_compression_log.log_warning(
    p_package => 'TEST_PACKAGE',
    p_procedure => 'test_procedure',
    p_message => 'Test WARNING message',
    p_object_owner => 'TEST_SCHEMA',
    p_object_name => 'TEST_TABLE'
  );
  v_test_count := v_test_count + 1;
  DBMS_OUTPUT.PUT_LINE('✓ Test 2: WARNING logging successful');

  -- Test 3: ERROR logging
  pkg_compression_log.log_error(
    p_package => 'TEST_PACKAGE',
    p_procedure => 'test_procedure',
    p_message => 'Test ERROR message',
    p_error => 'ORA-00001: unique constraint violated',
    p_object_owner => 'TEST_SCHEMA',
    p_object_name => 'TEST_TABLE',
    p_object_type => 'TABLE'
  );
  v_test_count := v_test_count + 1;
  DBMS_OUTPUT.PUT_LINE('✓ Test 3: ERROR logging successful');

  -- Test 4: DEBUG logging (may not appear if log level is INFO)
  pkg_compression_log.log_debug(
    p_package => 'TEST_PACKAGE',
    p_procedure => 'test_procedure',
    p_message => 'Test DEBUG message - may not appear based on log level'
  );
  v_test_count := v_test_count + 1;
  DBMS_OUTPUT.PUT_LINE('✓ Test 4: DEBUG logging successful (check log level)');

  -- Test 5: Get log level
  DBMS_OUTPUT.PUT_LINE('✓ Test 5: Current log level = ' || pkg_compression_log.get_log_level);

  DBMS_OUTPUT.PUT_LINE('');
  DBMS_OUTPUT.PUT_LINE('All ' || v_test_count || ' tests completed successfully!');
  DBMS_OUTPUT.PUT_LINE('');

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('✗ Test failed: ' || SQLERRM);
    RAISE;
END;
/

-- Display recent log entries
PROMPT
PROMPT Recent log entries (last 5):

SELECT
  TO_CHAR(LOG_TIMESTAMP, 'YYYY-MM-DD HH24:MI:SS') AS log_time,
  LOG_LEVEL,
  PACKAGE_NAME,
  PROCEDURE_NAME,
  SUBSTR(LOG_MESSAGE, 1, 60) AS message,
  OBJECT_OWNER,
  OBJECT_NAME
FROM T_COMPRESSION_LOG
WHERE LOG_DATE >= SYSDATE - 1
ORDER BY LOG_TIMESTAMP DESC
FETCH FIRST 5 ROWS ONLY;

-- Display log statistics
PROMPT
PROMPT Log statistics:

SELECT
  LOG_LEVEL,
  COUNT(*) AS total_entries,
  COUNT(DISTINCT PACKAGE_NAME) AS unique_packages,
  MIN(LOG_TIMESTAMP) AS first_entry,
  MAX(LOG_TIMESTAMP) AS last_entry
FROM T_COMPRESSION_LOG
GROUP BY LOG_LEVEL
ORDER BY
  CASE LOG_LEVEL
    WHEN 'FATAL' THEN 1
    WHEN 'ERROR' THEN 2
    WHEN 'WARNING' THEN 3
    WHEN 'INFO' THEN 4
    WHEN 'DEBUG' THEN 5
  END;

PROMPT
PROMPT ================================================================================
PROMPT PKG_COMPRESSION_LOG Package Installation Complete!
PROMPT ================================================================================
PROMPT
PROMPT Package Features:
PROMPT   ✓ Autonomous transaction logging (survives rollbacks)
PROMPT   ✓ Multiple log levels (DEBUG, INFO, WARNING, ERROR, FATAL)
PROMPT   ✓ Automatic context capture (session, user, program)
PROMPT   ✓ Error backtrace and call stack capture
PROMPT   ✓ Object-specific logging for analysis tracking
PROMPT   ✓ Performance-optimized with indexes
PROMPT   ✓ Built-in maintenance procedures (purge, archive)
PROMPT
PROMPT Usage Examples:
PROMPT   -- Log info message
PROMPT   pkg_compression_log.log_info('PACKAGE_NAME', 'proc_name', 'Message');
PROMPT
PROMPT   -- Log error with context
PROMPT   pkg_compression_log.log_error(
PROMPT     p_package => 'PKG_NAME',
PROMPT     p_procedure => 'proc_name',
PROMPT     p_message => 'Error occurred',
PROMPT     p_error => SQLERRM,
PROMPT     p_object_owner => 'SCHEMA',
PROMPT     p_object_name => 'TABLE_NAME'
PROMPT   );
PROMPT
PROMPT   -- Set log level (DEBUG=10, INFO=20, WARNING=30, ERROR=40, FATAL=50)
PROMPT   pkg_compression_log.set_log_level(pkg_compression_log.c_level_debug);
PROMPT
PROMPT   -- Purge old logs (older than 90 days)
PROMPT   v_deleted := pkg_compression_log.purge_logs(90);
PROMPT
PROMPT ================================================================================

SET ECHO OFF
