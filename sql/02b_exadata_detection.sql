/*******************************************************************************
 * HCC Compression Advisor - Exadata Platform Detection
 * Version: 1.0.0
 * Date: 2025-11-13
 *
 * DESCRIPTION:
 *   Automatic detection of Oracle Exadata platform to enable HCC compression
 *   features when running on Exadata hardware. Falls back gracefully to
 *   standard compression types on non-Exadata platforms.
 *
 * FEATURES:
 *   - Multi-method Exadata detection (CELL_OFFLOAD_PROCESSING, V$CELL views)
 *   - Platform-aware compression type mapping (HCC on Exadata, BASIC/OLTP elsewhere)
 *   - Performance-optimized with package variable caching
 *   - Comprehensive logging and debugging
 *
 * DETECTION METHODS:
 *   1. Check CELL_OFFLOAD_PROCESSING parameter (primary method)
 *   2. Query V$CELL view existence and data
 *   3. Check GV$CELL_CONFIG for cell configuration
 *
 * COMPRESSION TYPE MAPPING:
 *   Exadata Platform:
 *     - QUERY LOW (COMPRESS FOR QUERY LOW)
 *     - QUERY HIGH (COMPRESS FOR QUERY HIGH)
 *     - ARCHIVE LOW (COMPRESS FOR ARCHIVE LOW)
 *     - ARCHIVE HIGH (COMPRESS FOR ARCHIVE HIGH)
 *
 *   Standard Platform (Oracle 23c Free):
 *     - BASIC (COMPRESS BASIC)
 *     - OLTP (COMPRESS FOR OLTP / ADVANCED)
 *
 * USAGE:
 *   -- Detect platform and initialize
 *   EXEC PKG_EXADATA_DETECTION.initialize_platform;
 *
 *   -- Check if running on Exadata
 *   SELECT PKG_EXADATA_DETECTION.is_exadata FROM DUAL;
 *
 *   -- Get mapped compression type
 *   SELECT PKG_EXADATA_DETECTION.get_compression_type('QUERY_LOW') FROM DUAL;
 *
 * DEPENDENCIES:
 *   - V$PARAMETER (for CELL_OFFLOAD_PROCESSING)
 *   - V$CELL (for cell storage detection)
 *   - GV$CELL_CONFIG (optional, for detailed info)
 *
 ******************************************************************************/

SET ECHO ON
SET FEEDBACK ON
SET SERVEROUTPUT ON SIZE UNLIMITED
SET LINESIZE 200
SET PAGESIZE 1000

PROMPT ================================================================================
PROMPT Creating Exadata Platform Detection Package
PROMPT ================================================================================

-- ============================================================================
-- SECTION 1: PLATFORM CONFIGURATION TABLE
-- ============================================================================

PROMPT
PROMPT Creating platform configuration table...

-- ----------------------------------------------------------------------------
-- Table: T_PLATFORM_CONFIG
-- Purpose: Store platform detection results and compression type mappings
-- ----------------------------------------------------------------------------
CREATE TABLE T_PLATFORM_CONFIG (
    -- Configuration Key
    CONFIG_KEY              VARCHAR2(50) NOT NULL,
    CONFIG_VALUE            VARCHAR2(4000),
    CONFIG_TYPE             VARCHAR2(30),
    -- Platform Information
    PLATFORM_TYPE           VARCHAR2(30),   -- EXADATA, STANDARD, UNKNOWN
    DETECTION_METHOD        VARCHAR2(100),  -- How platform was detected
    DETECTION_CONFIDENCE    NUMBER(3,0),    -- 0-100 confidence score
    -- Capabilities
    HCC_AVAILABLE           VARCHAR2(1) DEFAULT 'N',
    SMART_SCAN_AVAILABLE    VARCHAR2(1) DEFAULT 'N',
    STORAGE_CELLS_COUNT     NUMBER,
    -- Detection Results
    CELL_OFFLOAD_ENABLED    VARCHAR2(10),
    V$CELL_ACCESSIBLE       VARCHAR2(1) DEFAULT 'N',
    CELL_CONFIG_DATA        CLOB,
    -- Audit
    LAST_DETECTED           TIMESTAMP DEFAULT SYSTIMESTAMP,
    DETECTED_BY             VARCHAR2(128) DEFAULT USER,
    LAST_VERIFIED           TIMESTAMP,
    -- Constraints
    CONSTRAINT PK_PLATFORM_CONFIG PRIMARY KEY (CONFIG_KEY),
    CONSTRAINT CHK_PLATFORM_TYPE CHECK (
        PLATFORM_TYPE IN ('EXADATA', 'STANDARD', 'UNKNOWN')
    ),
    CONSTRAINT CHK_HCC_AVAILABLE CHECK (HCC_AVAILABLE IN ('Y', 'N')),
    CONSTRAINT CHK_SMART_SCAN CHECK (SMART_SCAN_AVAILABLE IN ('Y', 'N')),
    CONSTRAINT CHK_V$CELL_ACCESS CHECK (V$CELL_ACCESSIBLE IN ('Y', 'N'))
);
COMMENT ON TABLE T_PLATFORM_CONFIG IS 'Platform detection results and compression type mappings';
COMMENT ON COLUMN T_PLATFORM_CONFIG.DETECTION_CONFIDENCE IS 'Confidence score 0-100 for platform detection accuracy';
-- Create index for quick lookup
CREATE UNIQUE INDEX UNQ_PLATFORM_CONFIG_KEY ON T_PLATFORM_CONFIG(CONFIG_KEY);
-- ----------------------------------------------------------------------------
-- Table: T_COMPRESSION_TYPE_MAP
-- Purpose: Map logical compression types to platform-specific implementations
-- ----------------------------------------------------------------------------
CREATE TABLE T_COMPRESSION_TYPE_MAP (
    -- Primary Key
    MAP_ID                  NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    -- Logical Type (platform-independent)
    LOGICAL_TYPE            VARCHAR2(30) NOT NULL,
    LOGICAL_DESCRIPTION     VARCHAR2(200),
    COMPRESSION_CATEGORY    VARCHAR2(20),  -- BASIC, OLTP, QUERY, ARCHIVE
    -- Platform-Specific Mapping
    PLATFORM_TYPE           VARCHAR2(30) NOT NULL,
    PHYSICAL_TYPE           VARCHAR2(50) NOT NULL,
    DDL_CLAUSE              VARCHAR2(100) NOT NULL,
    -- Characteristics
    EXPECTED_RATIO_MIN      NUMBER(4,2),
    EXPECTED_RATIO_MAX      NUMBER(4,2),
    CPU_OVERHEAD            VARCHAR2(10),  -- LOW, MEDIUM, HIGH
    WRITE_PENALTY           VARCHAR2(10),  -- LOW, MEDIUM, HIGH
    READ_PERFORMANCE        VARCHAR2(10),  -- EXCELLENT, GOOD, FAIR
    -- Availability
    IS_AVAILABLE            VARCHAR2(1) DEFAULT 'Y',
    REQUIRES_LICENSE        VARCHAR2(1) DEFAULT 'N',
    MIN_DB_VERSION          VARCHAR2(20),
    -- Priority for selection
    PRIORITY                NUMBER DEFAULT 50,
    -- Audit
    CREATED_DATE            TIMESTAMP DEFAULT SYSTIMESTAMP,
    CREATED_BY              VARCHAR2(128) DEFAULT USER,
    -- Constraints
    CONSTRAINT PK_COMPRESSION_TYPE_MAP PRIMARY KEY (MAP_ID),
    CONSTRAINT UNQ_TYPE_PLATFORM UNIQUE (LOGICAL_TYPE, PLATFORM_TYPE),
    CONSTRAINT CHK_MAP_PLATFORM_TYPE CHECK (
        PLATFORM_TYPE IN ('EXADATA', 'STANDARD', 'BOTH')
    ),
    CONSTRAINT CHK_MAP_IS_AVAILABLE CHECK (IS_AVAILABLE IN ('Y', 'N')),
    CONSTRAINT CHK_MAP_REQUIRES_LICENSE CHECK (REQUIRES_LICENSE IN ('Y', 'N')),
    CONSTRAINT CHK_MAP_CPU_OVERHEAD CHECK (
        CPU_OVERHEAD IN ('LOW', 'MEDIUM', 'HIGH')
    ),
    CONSTRAINT CHK_MAP_WRITE_PENALTY CHECK (
        WRITE_PENALTY IN ('LOW', 'MEDIUM', 'HIGH')
    ),
    CONSTRAINT CHK_MAP_READ_PERFORMANCE CHECK (
        READ_PERFORMANCE IN ('EXCELLENT', 'GOOD', 'FAIR')
    )
);
COMMENT ON TABLE T_COMPRESSION_TYPE_MAP IS 'Platform-aware compression type mappings';
CREATE INDEX IDX_COMP_MAP_LOGICAL ON T_COMPRESSION_TYPE_MAP(LOGICAL_TYPE, PRIORITY);
CREATE INDEX IDX_COMP_MAP_PLATFORM ON T_COMPRESSION_TYPE_MAP(PLATFORM_TYPE, IS_AVAILABLE);
-- ============================================================================
-- SECTION 2: PACKAGE SPECIFICATION
-- ============================================================================
PROMPT
PROMPT Creating PKG_EXADATA_DETECTION package specification...
CREATE OR REPLACE PACKAGE PKG_EXADATA_DETECTION AS
    -- Package version
    C_VERSION CONSTANT VARCHAR2(10) := '1.0.0';
    -- Platform types
    C_PLATFORM_EXADATA  CONSTANT VARCHAR2(30) := 'EXADATA';
    C_PLATFORM_STANDARD CONSTANT VARCHAR2(30) := 'STANDARD';
    C_PLATFORM_UNKNOWN  CONSTANT VARCHAR2(30) := 'UNKNOWN';
    -- Detection confidence levels
    C_CONFIDENCE_HIGH   CONSTANT NUMBER := 90;
    C_CONFIDENCE_MEDIUM CONSTANT NUMBER := 60;
    C_CONFIDENCE_LOW    CONSTANT NUMBER := 30;
    /**
     * Initialize platform detection (run once at startup)
     * Detects Exadata and populates configuration tables
     */
    PROCEDURE initialize_platform;
    /**
     * Check if running on Exadata platform
     * @return TRUE if Exadata, FALSE otherwise
     */
    FUNCTION is_exadata RETURN BOOLEAN;
    /**
     * Get current platform type
     * @return EXADATA, STANDARD, or UNKNOWN
     */
    FUNCTION get_platform_type RETURN VARCHAR2;
    /**
     * Get platform detection confidence score
     * @return Confidence score 0-100
     */
    FUNCTION get_confidence_score RETURN NUMBER;
    /**
     * Check if HCC compression is available
     * @return TRUE if HCC available, FALSE otherwise
     */
    FUNCTION is_hcc_available RETURN BOOLEAN;
    /**
     * Get mapped compression type for current platform
     * @param p_logical_type Logical compression type (QUERY_LOW, ARCHIVE_HIGH, etc)
     * @return Physical compression type clause for DDL
     */
    FUNCTION get_compression_type(
        p_logical_type IN VARCHAR2
    ) RETURN VARCHAR2;
    /**
     * Get compression DDL clause for current platform
     * @param p_logical_type Logical compression type
     * @return Complete DDL clause (e.g., "COMPRESS FOR QUERY LOW")
     */
    FUNCTION get_compression_clause(
        p_logical_type IN VARCHAR2
    ) RETURN VARCHAR2;
    /**
     * Get all available compression types for current platform
     * @return Cursor with available compression types
     */
    FUNCTION get_available_types RETURN SYS_REFCURSOR;
    /**
     * Verify platform detection and update confidence
     * Should be run periodically to ensure detection accuracy
     */
    PROCEDURE verify_platform;
    /**
     * Get platform detection details for debugging
     * @return Cursor with detection details
     */
    FUNCTION get_detection_details RETURN SYS_REFCURSOR;
    /**
     * Force platform detection refresh
     * Clears cache and re-runs all detection methods
     */
    PROCEDURE refresh_detection;
    /**
     * Get storage cell count (Exadata only)
     * @return Number of storage cells, 0 if not Exadata
     */
    FUNCTION get_cell_count RETURN NUMBER;
END PKG_EXADATA_DETECTION;
/

-- ============================================================================
-- SECTION 3: PACKAGE BODY
-- ============================================================================

PROMPT
PROMPT Creating PKG_EXADATA_DETECTION package body...

CREATE OR REPLACE PACKAGE BODY PKG_EXADATA_DETECTION AS
    -- ========================================================================
    -- Private Package Variables (cached for performance)
    -- ========================================================================
    g_platform_type         VARCHAR2(30) := NULL;
    g_is_exadata            BOOLEAN := NULL;
    g_hcc_available         BOOLEAN := NULL;
    g_confidence_score      NUMBER := 0;
    g_cell_count            NUMBER := 0;
    g_initialized           BOOLEAN := FALSE;
    -- ========================================================================
    -- Private Utility Procedures
    -- ========================================================================
    /**
     * Log detection message
     */
    PROCEDURE log_message(
        p_message IN VARCHAR2,
        p_level IN VARCHAR2 DEFAULT 'INFO'
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        DBMS_OUTPUT.PUT_LINE('[' || p_level || '] ' ||
                            TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD HH24:MI:SS.FF3') ||
                            ' - ' || p_message);
        COMMIT;
    END log_message;
    /**
     * Check CELL_OFFLOAD_PROCESSING parameter
     */
    FUNCTION check_cell_offload_parameter RETURN BOOLEAN IS
        v_cell_offload VARCHAR2(10);
    BEGIN
        SELECT value
        INTO v_cell_offload
        FROM v$parameter
        WHERE name = 'cell_offload_processing';
        log_message('CELL_OFFLOAD_PROCESSING = ' || v_cell_offload, 'DEBUG');
        -- Update config
        MERGE INTO T_PLATFORM_CONFIG t
        USING (SELECT 'CELL_OFFLOAD_ENABLED' AS key, v_cell_offload AS val FROM DUAL) s
        ON (t.config_key = s.key)
        WHEN MATCHED THEN
            UPDATE SET t.config_value = s.val, t.last_detected = SYSTIMESTAMP
        WHEN NOT MATCHED THEN
            INSERT (config_key, config_value, config_type, last_detected)
            VALUES (s.key, s.val, 'PARAMETER', SYSTIMESTAMP);
        COMMIT;
        RETURN UPPER(v_cell_offload) = 'TRUE';
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            log_message('CELL_OFFLOAD_PROCESSING parameter not found', 'DEBUG');
            RETURN FALSE;
        WHEN OTHERS THEN
            log_message('Error checking cell_offload_processing: ' || SQLERRM, 'WARN');
            RETURN FALSE;
    END check_cell_offload_parameter;
    /**
     * Check V$CELL view accessibility and data
     */
    FUNCTION check_vcell_view RETURN BOOLEAN IS
        v_cell_count NUMBER := 0;
        v_accessible BOOLEAN := FALSE;
    BEGIN
        -- Try to query V$CELL
        SELECT COUNT(*)
        INTO v_cell_count
        FROM v$cell
        WHERE ROWNUM <= 100;
        v_accessible := v_cell_count > 0;
        log_message('V$CELL accessible: ' || CASE WHEN v_accessible THEN 'YES' ELSE 'NO' END ||
                   ', Cell count: ' || v_cell_count, 'DEBUG');
        -- Store cell count
        g_cell_count := v_cell_count;
        -- Update config
        MERGE INTO T_PLATFORM_CONFIG t
        USING (SELECT 'V$CELL_COUNT' AS key, TO_CHAR(v_cell_count) AS val FROM DUAL) s
        ON (t.config_key = s.key)
        WHEN MATCHED THEN
            UPDATE SET t.config_value = s.val,
                      t.v$cell_accessible = 'Y',
                      t.storage_cells_count = v_cell_count,
                      t.last_detected = SYSTIMESTAMP
        WHEN NOT MATCHED THEN
            INSERT (config_key, config_value, config_type, v$cell_accessible,
                   storage_cells_count, last_detected)
            VALUES (s.key, s.val, 'VIEW', 'Y', v_cell_count, SYSTIMESTAMP);
        COMMIT;
        RETURN v_accessible;
    EXCEPTION
        WHEN OTHERS THEN
            log_message('V$CELL not accessible or empty: ' || SQLERRM, 'DEBUG');
            -- Update config
            MERGE INTO T_PLATFORM_CONFIG t
            USING (SELECT 'V$CELL_ACCESSIBLE' AS key FROM DUAL) s
            ON (t.config_key = s.key)
            WHEN MATCHED THEN
                UPDATE SET t.config_value = 'N',
                          t.v$cell_accessible = 'N',
                          t.last_detected = SYSTIMESTAMP
            WHEN NOT MATCHED THEN
                INSERT (config_key, config_value, config_type, v$cell_accessible, last_detected)
                VALUES (s.key, 'N', 'VIEW', 'N', SYSTIMESTAMP);
            COMMIT;
            RETURN FALSE;
    END check_vcell_view;
    /**
     * Check GV$CELL_CONFIG for additional confirmation
     */
    FUNCTION check_cell_config RETURN BOOLEAN IS
        v_config_count NUMBER := 0;
        v_config_data VARCHAR2(4000);
    BEGIN
        -- Try to query GV$CELL_CONFIG
        SELECT COUNT(*)
        INTO v_config_count
        FROM gv$cell_config
        WHERE ROWNUM <= 10;
        IF v_config_count > 0 THEN
            -- Get sample config data
            SELECT LISTAGG(conftype || '=' || confval, '; ')
                   WITHIN GROUP (ORDER BY conftype)
            INTO v_config_data
            FROM (
                SELECT conftype, confval
                FROM gv$cell_config
                WHERE ROWNUM <= 5
            );
            log_message('GV$CELL_CONFIG data found: ' || v_config_count || ' rows', 'DEBUG');
            -- Update config
            MERGE INTO T_PLATFORM_CONFIG t
            USING (SELECT 'CELL_CONFIG_DATA' AS key, v_config_data AS val FROM DUAL) s
            ON (t.config_key = s.key)
            WHEN MATCHED THEN
                UPDATE SET t.config_value = v_config_data,
                          t.cell_config_data = v_config_data,
                          t.last_detected = SYSTIMESTAMP
            WHEN NOT MATCHED THEN
                INSERT (config_key, config_value, config_type, cell_config_data, last_detected)
                VALUES (s.key, v_config_data, 'CONFIG', v_config_data, SYSTIMESTAMP);
            COMMIT;
            RETURN TRUE;
        END IF;
        RETURN FALSE;
    EXCEPTION
        WHEN OTHERS THEN
            log_message('GV$CELL_CONFIG not accessible: ' || SQLERRM, 'DEBUG');
            RETURN FALSE;
    END check_cell_config;
    /**
     * Perform comprehensive platform detection
     */
    PROCEDURE detect_platform IS
        v_cell_offload      BOOLEAN := FALSE;
        v_vcell_accessible  BOOLEAN := FALSE;
        v_cell_config       BOOLEAN := FALSE;
        v_detection_methods VARCHAR2(500);
        v_confidence        NUMBER := 0;
        v_platform          VARCHAR2(30);
        -- VARCHAR2 helpers for SQL (BOOLEAN not allowed in SQL)
        v_hcc_yn            VARCHAR2(1);
        v_cell_offload_yn   VARCHAR2(1);
        v_cell_offload_str  VARCHAR2(5);
        v_vcell_yn          VARCHAR2(1);
    BEGIN
        log_message('Starting platform detection...', 'INFO');
        -- Run all detection methods
        v_cell_offload := check_cell_offload_parameter;
        v_vcell_accessible := check_vcell_view;
        v_cell_config := check_cell_config;
        -- Build detection methods string
        v_detection_methods := '';
        IF v_cell_offload THEN
            v_detection_methods := v_detection_methods || 'CELL_OFFLOAD_PROCESSING; ';
            v_confidence := v_confidence + 40;
        END IF;
        IF v_vcell_accessible THEN
            v_detection_methods := v_detection_methods || 'V$CELL; ';
            v_confidence := v_confidence + 40;
        END IF;
        IF v_cell_config THEN
            v_detection_methods := v_detection_methods || 'GV$CELL_CONFIG; ';
            v_confidence := v_confidence + 20;
        END IF;
        -- Determine platform type
        IF v_cell_offload AND v_vcell_accessible THEN
            v_platform := C_PLATFORM_EXADATA;
            g_is_exadata := TRUE;
            g_hcc_available := TRUE;
        ELSIF v_cell_offload OR v_vcell_accessible THEN
            v_platform := C_PLATFORM_EXADATA;
            g_is_exadata := TRUE;
            g_hcc_available := TRUE;
            v_confidence := LEAST(v_confidence, C_CONFIDENCE_MEDIUM);
        ELSE
            v_platform := C_PLATFORM_STANDARD;
            g_is_exadata := FALSE;
            g_hcc_available := FALSE;
            v_confidence := 100; -- Confident it's NOT Exadata
        END IF;
        -- Store results
        g_platform_type := v_platform;
        g_confidence_score := v_confidence;
        -- Convert BOOLEANs to VARCHAR2 for SQL usage
        IF g_hcc_available THEN v_hcc_yn := 'Y'; ELSE v_hcc_yn := 'N'; END IF;
        IF v_cell_offload THEN v_cell_offload_yn := 'Y'; ELSE v_cell_offload_yn := 'N'; END IF;
        IF v_cell_offload THEN v_cell_offload_str := 'TRUE'; ELSE v_cell_offload_str := 'FALSE'; END IF;
        IF v_vcell_accessible THEN v_vcell_yn := 'Y'; ELSE v_vcell_yn := 'N'; END IF;
        -- Update main config record
        MERGE INTO T_PLATFORM_CONFIG t
        USING (SELECT 'PLATFORM_TYPE' AS key FROM DUAL) s
        ON (t.config_key = s.key)
        WHEN MATCHED THEN
            UPDATE SET
                t.config_value = v_platform,
                t.platform_type = v_platform,
                t.detection_method = v_detection_methods,
                t.detection_confidence = v_confidence,
                t.hcc_available = v_hcc_yn,
                t.smart_scan_available = v_cell_offload_yn,
                t.cell_offload_enabled = v_cell_offload_str,
                t.v$cell_accessible = v_vcell_yn,
                t.storage_cells_count = g_cell_count,
                t.last_detected = SYSTIMESTAMP,
                t.detected_by = USER
        WHEN NOT MATCHED THEN
            INSERT (
                config_key, config_value, config_type, platform_type,
                detection_method, detection_confidence, hcc_available,
                smart_scan_available, cell_offload_enabled, v$cell_accessible,
                storage_cells_count, last_detected, detected_by
            ) VALUES (
                s.key, v_platform, 'PLATFORM', v_platform,
                v_detection_methods, v_confidence,
                v_hcc_yn, v_cell_offload_yn, v_cell_offload_str, v_vcell_yn,
                g_cell_count, SYSTIMESTAMP, USER
            );
        COMMIT;
        log_message('Platform detection complete: ' || v_platform ||
                   ' (Confidence: ' || v_confidence || '%)', 'INFO');
        log_message('HCC Available: ' || v_hcc_yn, 'INFO');
        log_message('Detection methods: ' || v_detection_methods, 'INFO');
    EXCEPTION
        WHEN OTHERS THEN
            log_message('Error during platform detection: ' || SQLERRM, 'ERROR');
            g_platform_type := C_PLATFORM_UNKNOWN;
            g_is_exadata := FALSE;
            g_hcc_available := FALSE;
            g_confidence_score := 0;
            RAISE;
    END detect_platform;
    /**
     * Initialize compression type mappings
     */
    PROCEDURE initialize_compression_mappings IS
    BEGIN
        log_message('Initializing compression type mappings...', 'INFO');
        -- Clear existing mappings
        DELETE FROM T_COMPRESSION_TYPE_MAP;
        -- ====================================================================
        -- EXADATA PLATFORM MAPPINGS (HCC)
        -- ====================================================================
        -- QUERY LOW
        INSERT INTO T_COMPRESSION_TYPE_MAP (
            LOGICAL_TYPE, LOGICAL_DESCRIPTION, COMPRESSION_CATEGORY,
            PLATFORM_TYPE, PHYSICAL_TYPE, DDL_CLAUSE,
            EXPECTED_RATIO_MIN, EXPECTED_RATIO_MAX,
            CPU_OVERHEAD, WRITE_PENALTY, READ_PERFORMANCE,
            IS_AVAILABLE, REQUIRES_LICENSE, PRIORITY
        ) VALUES (
            'QUERY_LOW', 'HCC Query Low - Balanced query performance and compression',
            'QUERY', 'EXADATA', 'COMPRESS FOR QUERY LOW', 'COMPRESS FOR QUERY LOW',
            4.0, 8.0, 'LOW', 'MEDIUM', 'EXCELLENT',
            'Y', 'N', 80
        );
        -- QUERY HIGH
        INSERT INTO T_COMPRESSION_TYPE_MAP (
            LOGICAL_TYPE, LOGICAL_DESCRIPTION, COMPRESSION_CATEGORY,
            PLATFORM_TYPE, PHYSICAL_TYPE, DDL_CLAUSE,
            EXPECTED_RATIO_MIN, EXPECTED_RATIO_MAX,
            CPU_OVERHEAD, WRITE_PENALTY, READ_PERFORMANCE,
            IS_AVAILABLE, REQUIRES_LICENSE, PRIORITY
        ) VALUES (
            'QUERY_HIGH', 'HCC Query High - Higher compression for queries',
            'QUERY', 'EXADATA', 'COMPRESS FOR QUERY HIGH', 'COMPRESS FOR QUERY HIGH',
            6.0, 12.0, 'MEDIUM', 'MEDIUM', 'EXCELLENT',
            'Y', 'N', 70
        );
        -- ARCHIVE LOW
        INSERT INTO T_COMPRESSION_TYPE_MAP (
            LOGICAL_TYPE, LOGICAL_DESCRIPTION, COMPRESSION_CATEGORY,
            PLATFORM_TYPE, PHYSICAL_TYPE, DDL_CLAUSE,
            EXPECTED_RATIO_MIN, EXPECTED_RATIO_MAX,
            CPU_OVERHEAD, WRITE_PENALTY, READ_PERFORMANCE,
            IS_AVAILABLE, REQUIRES_LICENSE, PRIORITY
        ) VALUES (
            'ARCHIVE_LOW', 'HCC Archive Low - High compression for archival data',
            'ARCHIVE', 'EXADATA', 'COMPRESS FOR ARCHIVE LOW', 'COMPRESS FOR ARCHIVE LOW',
            8.0, 15.0, 'MEDIUM', 'HIGH', 'GOOD',
            'Y', 'N', 60
        );
        -- ARCHIVE HIGH
        INSERT INTO T_COMPRESSION_TYPE_MAP (
            LOGICAL_TYPE, LOGICAL_DESCRIPTION, COMPRESSION_CATEGORY,
            PLATFORM_TYPE, PHYSICAL_TYPE, DDL_CLAUSE,
            EXPECTED_RATIO_MIN, EXPECTED_RATIO_MAX,
            CPU_OVERHEAD, WRITE_PENALTY, READ_PERFORMANCE,
            IS_AVAILABLE, REQUIRES_LICENSE, PRIORITY
        ) VALUES (
            'ARCHIVE_HIGH', 'HCC Archive High - Maximum compression for cold data',
            'ARCHIVE', 'EXADATA', 'COMPRESS FOR ARCHIVE HIGH', 'COMPRESS FOR ARCHIVE HIGH',
            10.0, 20.0, 'HIGH', 'HIGH', 'GOOD',
            'Y', 'N', 50
        );
        -- ====================================================================
        -- STANDARD PLATFORM MAPPINGS (Oracle 23c Free)
        -- ====================================================================
        -- QUERY_LOW -> OLTP (fallback)
        INSERT INTO T_COMPRESSION_TYPE_MAP (
            LOGICAL_TYPE, LOGICAL_DESCRIPTION, COMPRESSION_CATEGORY,
            PLATFORM_TYPE, PHYSICAL_TYPE, DDL_CLAUSE,
            EXPECTED_RATIO_MIN, EXPECTED_RATIO_MAX,
            CPU_OVERHEAD, WRITE_PENALTY, READ_PERFORMANCE,
            IS_AVAILABLE, REQUIRES_LICENSE, PRIORITY
        ) VALUES (
            'QUERY_LOW', 'OLTP compression (fallback for non-Exadata)',
            'OLTP', 'STANDARD', 'COMPRESS FOR OLTP', 'COMPRESS FOR OLTP',
            2.0, 3.5, 'LOW', 'LOW', 'GOOD',
            'Y', 'N', 80
        );
        -- QUERY_HIGH -> OLTP (fallback)
        INSERT INTO T_COMPRESSION_TYPE_MAP (
            LOGICAL_TYPE, LOGICAL_DESCRIPTION, COMPRESSION_CATEGORY,
            PLATFORM_TYPE, PHYSICAL_TYPE, DDL_CLAUSE,
            EXPECTED_RATIO_MIN, EXPECTED_RATIO_MAX,
            CPU_OVERHEAD, WRITE_PENALTY, READ_PERFORMANCE,
            IS_AVAILABLE, REQUIRES_LICENSE, PRIORITY
        ) VALUES (
            'QUERY_HIGH', 'OLTP compression (fallback for non-Exadata)',
            'OLTP', 'STANDARD', 'COMPRESS FOR OLTP', 'COMPRESS FOR OLTP',
            2.0, 3.5, 'LOW', 'LOW', 'GOOD',
            'Y', 'N', 70
        );
        -- ARCHIVE_LOW -> BASIC (fallback)
        INSERT INTO T_COMPRESSION_TYPE_MAP (
            LOGICAL_TYPE, LOGICAL_DESCRIPTION, COMPRESSION_CATEGORY,
            PLATFORM_TYPE, PHYSICAL_TYPE, DDL_CLAUSE,
            EXPECTED_RATIO_MIN, EXPECTED_RATIO_MAX,
            CPU_OVERHEAD, WRITE_PENALTY, READ_PERFORMANCE,
            IS_AVAILABLE, REQUIRES_LICENSE, PRIORITY
        ) VALUES (
            'ARCHIVE_LOW', 'Basic compression (fallback for non-Exadata)',
            'BASIC', 'STANDARD', 'COMPRESS BASIC', 'COMPRESS BASIC',
            2.0, 3.0, 'LOW', 'MEDIUM', 'GOOD',
            'Y', 'N', 60
        );
        -- ARCHIVE_HIGH -> BASIC (fallback)
        INSERT INTO T_COMPRESSION_TYPE_MAP (
            LOGICAL_TYPE, LOGICAL_DESCRIPTION, COMPRESSION_CATEGORY,
            PLATFORM_TYPE, PHYSICAL_TYPE, DDL_CLAUSE,
            EXPECTED_RATIO_MIN, EXPECTED_RATIO_MAX,
            CPU_OVERHEAD, WRITE_PENALTY, READ_PERFORMANCE,
            IS_AVAILABLE, REQUIRES_LICENSE, PRIORITY
        ) VALUES (
            'ARCHIVE_HIGH', 'Basic compression (fallback for non-Exadata)',
            'BASIC', 'STANDARD', 'COMPRESS BASIC', 'COMPRESS BASIC',
            2.0, 3.0, 'LOW', 'MEDIUM', 'GOOD',
            'Y', 'N', 50
        );
        -- ====================================================================
        -- COMMON MAPPINGS (Both platforms)
        -- ====================================================================
        -- BASIC
        INSERT INTO T_COMPRESSION_TYPE_MAP (
            LOGICAL_TYPE, LOGICAL_DESCRIPTION, COMPRESSION_CATEGORY,
            PLATFORM_TYPE, PHYSICAL_TYPE, DDL_CLAUSE,
            EXPECTED_RATIO_MIN, EXPECTED_RATIO_MAX,
            CPU_OVERHEAD, WRITE_PENALTY, READ_PERFORMANCE,
            IS_AVAILABLE, REQUIRES_LICENSE, PRIORITY
        ) VALUES (
            'BASIC', 'Basic table compression',
            'BASIC', 'BOTH', 'COMPRESS BASIC', 'COMPRESS BASIC',
            2.0, 3.0, 'LOW', 'MEDIUM', 'GOOD',
            'Y', 'N', 90
        );
        -- OLTP
        INSERT INTO T_COMPRESSION_TYPE_MAP (
            LOGICAL_TYPE, LOGICAL_DESCRIPTION, COMPRESSION_CATEGORY,
            PLATFORM_TYPE, PHYSICAL_TYPE, DDL_CLAUSE,
            EXPECTED_RATIO_MIN, EXPECTED_RATIO_MAX,
            CPU_OVERHEAD, WRITE_PENALTY, READ_PERFORMANCE,
            IS_AVAILABLE, REQUIRES_LICENSE, PRIORITY
        ) VALUES (
            'OLTP', 'OLTP/Advanced table compression',
            'OLTP', 'BOTH', 'COMPRESS FOR OLTP', 'COMPRESS FOR OLTP',
            2.0, 3.5, 'LOW', 'LOW', 'GOOD',
            'Y', 'N', 95
        );
        -- NOCOMPRESS
        INSERT INTO T_COMPRESSION_TYPE_MAP (
            LOGICAL_TYPE, LOGICAL_DESCRIPTION, COMPRESSION_CATEGORY,
            PLATFORM_TYPE, PHYSICAL_TYPE, DDL_CLAUSE,
            EXPECTED_RATIO_MIN, EXPECTED_RATIO_MAX,
            CPU_OVERHEAD, WRITE_PENALTY, READ_PERFORMANCE,
            IS_AVAILABLE, REQUIRES_LICENSE, PRIORITY
        ) VALUES (
            'NONE', 'No compression',
            'BASIC', 'BOTH', 'NOCOMPRESS', 'NOCOMPRESS',
            1.0, 1.0, 'LOW', 'LOW', 'EXCELLENT',
            'Y', 'N', 100
        );
        COMMIT;
        log_message('Compression type mappings initialized successfully', 'INFO');
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            log_message('Error initializing compression mappings: ' || SQLERRM, 'ERROR');
            RAISE;
    END initialize_compression_mappings;
    -- ========================================================================
    -- Public Procedures Implementation
    -- ========================================================================
    PROCEDURE initialize_platform IS
    BEGIN
        log_message('=== PKG_EXADATA_DETECTION Initialization Starting ===', 'INFO');
        log_message('Version: ' || C_VERSION, 'INFO');
        -- Detect platform
        detect_platform;
        -- Initialize compression mappings
        initialize_compression_mappings;
        -- Mark as initialized
        g_initialized := TRUE;
        log_message('=== Initialization Complete ===', 'INFO');
        log_message('Platform: ' || g_platform_type, 'INFO');
        log_message('Exadata: ' || CASE WHEN g_is_exadata THEN 'YES' ELSE 'NO' END, 'INFO');
        log_message('HCC Available: ' || CASE WHEN g_hcc_available THEN 'YES' ELSE 'NO' END, 'INFO');
        log_message('Confidence: ' || g_confidence_score || '%', 'INFO');
        IF g_cell_count > 0 THEN
            log_message('Storage Cells: ' || g_cell_count, 'INFO');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            log_message('=== Initialization Failed ===', 'ERROR');
            log_message('Error: ' || SQLERRM, 'ERROR');
            g_initialized := FALSE;
            RAISE;
    END initialize_platform;
    FUNCTION is_exadata RETURN BOOLEAN IS
    BEGIN
        IF NOT g_initialized THEN
            initialize_platform;
        END IF;
        RETURN g_is_exadata;
    END is_exadata;
    FUNCTION get_platform_type RETURN VARCHAR2 IS
    BEGIN
        IF NOT g_initialized THEN
            initialize_platform;
        END IF;
        RETURN g_platform_type;
    END get_platform_type;
    FUNCTION get_confidence_score RETURN NUMBER IS
    BEGIN
        IF NOT g_initialized THEN
            initialize_platform;
        END IF;
        RETURN g_confidence_score;
    END get_confidence_score;
    FUNCTION is_hcc_available RETURN BOOLEAN IS
    BEGIN
        IF NOT g_initialized THEN
            initialize_platform;
        END IF;
        RETURN g_hcc_available;
    END is_hcc_available;
    FUNCTION get_compression_type(
        p_logical_type IN VARCHAR2
    ) RETURN VARCHAR2 IS
        v_physical_type VARCHAR2(50);
        v_platform      VARCHAR2(30);
    BEGIN
        IF NOT g_initialized THEN
            initialize_platform;
        END IF;
        v_platform := g_platform_type;
        -- Query mapping table
        BEGIN
            SELECT physical_type
            INTO v_physical_type
            FROM T_COMPRESSION_TYPE_MAP
            WHERE UPPER(logical_type) = UPPER(p_logical_type)
              AND (platform_type = v_platform OR platform_type = 'BOTH')
              AND is_available = 'Y'
            ORDER BY PRIORITY DESC
            FETCH FIRST 1 ROW ONLY;
            RETURN v_physical_type;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                log_message('No mapping found for logical type: ' || p_logical_type ||
                           ' on platform: ' || v_platform, 'WARN');
                -- Default fallback
                RETURN CASE
                    WHEN v_platform = C_PLATFORM_EXADATA THEN 'COMPRESS FOR QUERY LOW'
                    ELSE 'COMPRESS FOR OLTP'
                END;
        END;
    END get_compression_type;
    FUNCTION get_compression_clause(
        p_logical_type IN VARCHAR2
    ) RETURN VARCHAR2 IS
        v_ddl_clause VARCHAR2(100);
        v_platform   VARCHAR2(30);
    BEGIN
        IF NOT g_initialized THEN
            initialize_platform;
        END IF;
        v_platform := g_platform_type;
        -- Query mapping table
        BEGIN
            SELECT ddl_clause
            INTO v_ddl_clause
            FROM T_COMPRESSION_TYPE_MAP
            WHERE UPPER(logical_type) = UPPER(p_logical_type)
              AND (platform_type = v_platform OR platform_type = 'BOTH')
              AND is_available = 'Y'
            ORDER BY PRIORITY DESC
            FETCH FIRST 1 ROW ONLY;
            RETURN v_ddl_clause;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                log_message('No DDL clause found for logical type: ' || p_logical_type, 'WARN');
                RETURN 'COMPRESS FOR OLTP'; -- Safe default
        END;
    END get_compression_clause;
    FUNCTION get_available_types RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
        v_platform VARCHAR2(30);
    BEGIN
        IF NOT g_initialized THEN
            initialize_platform;
        END IF;
        v_platform := g_platform_type;
        OPEN v_cursor FOR
            SELECT
                logical_type,
                logical_description,
                compression_category,
                physical_type,
                ddl_clause,
                expected_ratio_min,
                expected_ratio_max,
                cpu_overhead,
                write_penalty,
                read_performance,
                requires_license
            FROM T_COMPRESSION_TYPE_MAP
            WHERE (platform_type = v_platform OR platform_type = 'BOTH')
              AND is_available = 'Y'
            ORDER BY priority DESC, logical_type;
        RETURN v_cursor;
    END get_available_types;
    PROCEDURE verify_platform IS
        v_previous_platform VARCHAR2(30);
        v_previous_confidence NUMBER;
    BEGIN
        log_message('Verifying platform detection...', 'INFO');
        -- Store previous values
        v_previous_platform := g_platform_type;
        v_previous_confidence := g_confidence_score;
        -- Re-run detection
        detect_platform;
        -- Check for changes
        IF v_previous_platform != g_platform_type THEN
            log_message('WARNING: Platform type changed from ' || v_previous_platform ||
                       ' to ' || g_platform_type, 'WARN');
        END IF;
        IF ABS(v_previous_confidence - g_confidence_score) > 20 THEN
            log_message('WARNING: Confidence score changed significantly from ' ||
                       v_previous_confidence || '% to ' || g_confidence_score || '%', 'WARN');
        END IF;
        -- Update verification timestamp
        UPDATE T_PLATFORM_CONFIG
        SET last_verified = SYSTIMESTAMP
        WHERE config_key = 'PLATFORM_TYPE';
        COMMIT;
        log_message('Platform verification complete', 'INFO');
    END verify_platform;
    FUNCTION get_detection_details RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
            SELECT
                config_key,
                config_value,
                config_type,
                platform_type,
                detection_method,
                detection_confidence,
                hcc_available,
                smart_scan_available,
                cell_offload_enabled,
                v$cell_accessible,
                storage_cells_count,
                TO_CHAR(last_detected, 'YYYY-MM-DD HH24:MI:SS') AS last_detected,
                detected_by,
                TO_CHAR(last_verified, 'YYYY-MM-DD HH24:MI:SS') AS last_verified
            FROM T_PLATFORM_CONFIG
            ORDER BY
                CASE config_key
                    WHEN 'PLATFORM_TYPE' THEN 1
                    ELSE 2
                END,
                config_key;
        RETURN v_cursor;
    END get_detection_details;
    PROCEDURE refresh_detection IS
    BEGIN
        log_message('Forcing platform detection refresh...', 'INFO');
        -- Clear cache
        g_platform_type := NULL;
        g_is_exadata := NULL;
        g_hcc_available := NULL;
        g_confidence_score := 0;
        g_cell_count := 0;
        g_initialized := FALSE;
        -- Re-initialize
        initialize_platform;
        log_message('Platform detection refreshed', 'INFO');
    END refresh_detection;
    FUNCTION get_cell_count RETURN NUMBER IS
    BEGIN
        IF NOT g_initialized THEN
            initialize_platform;
        END IF;
        RETURN g_cell_count;
    END get_cell_count;
BEGIN
    -- Package initialization
    -- Note: Do NOT auto-initialize here to avoid errors during package compilation
    -- Call initialize_platform explicitly after installation
    NULL;
END PKG_EXADATA_DETECTION;
/

-- ============================================================================
-- SECTION 4: GRANTS AND SYNONYMS
-- ============================================================================

PROMPT
PROMPT Creating grants and synonyms...

-- Grant execute on package
GRANT EXECUTE ON PKG_EXADATA_DETECTION TO PUBLIC;

-- Create public synonym
CREATE OR REPLACE PUBLIC SYNONYM PKG_EXADATA_DETECTION FOR PKG_EXADATA_DETECTION;

-- ============================================================================
-- SECTION 5: INITIALIZATION AND VERIFICATION
-- ============================================================================

PROMPT
PROMPT ================================================================================
PROMPT Initializing Exadata Detection
PROMPT ================================================================================

-- Initialize platform detection
BEGIN
    PKG_EXADATA_DETECTION.initialize_platform;
END;
/

PROMPT
PROMPT ================================================================================
PROMPT Platform Detection Results
PROMPT ================================================================================

-- Display detection results
DECLARE
    v_cursor SYS_REFCURSOR;
    v_config_key VARCHAR2(50);
    v_config_value VARCHAR2(4000);
    v_platform_type VARCHAR2(30);
    v_detection_method VARCHAR2(100);
    v_detection_confidence NUMBER;
    v_hcc_available VARCHAR2(1);
BEGIN
    DBMS_OUTPUT.PUT_LINE('Platform Detection Summary:');
    DBMS_OUTPUT.PUT_LINE('---------------------------');

    v_cursor := PKG_EXADATA_DETECTION.get_detection_details;

    LOOP
        FETCH v_cursor INTO v_config_key, v_config_value, v_platform_type, v_platform_type,
                           v_detection_method, v_detection_confidence, v_hcc_available,
                           v_config_value, v_config_value, v_config_value, v_detection_confidence,
                           v_config_value, v_config_value, v_config_value;
        EXIT WHEN v_cursor%NOTFOUND;

        DBMS_OUTPUT.PUT_LINE('  ' || RPAD(v_config_key, 30) || ': ' || v_config_value);
    END LOOP;

    CLOSE v_cursor;

    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Platform Type      : ' || PKG_EXADATA_DETECTION.get_platform_type);
    DBMS_OUTPUT.PUT_LINE('Is Exadata         : ' || CASE WHEN PKG_EXADATA_DETECTION.is_exadata THEN 'YES' ELSE 'NO' END);
    DBMS_OUTPUT.PUT_LINE('HCC Available      : ' || CASE WHEN PKG_EXADATA_DETECTION.is_hcc_available THEN 'YES' ELSE 'NO' END);
    DBMS_OUTPUT.PUT_LINE('Confidence Score   : ' || PKG_EXADATA_DETECTION.get_confidence_score || '%');
    DBMS_OUTPUT.PUT_LINE('Storage Cells      : ' || PKG_EXADATA_DETECTION.get_cell_count);
END;
/

PROMPT
PROMPT Available Compression Types:
PROMPT ---------------------------

DECLARE
    v_cursor SYS_REFCURSOR;
    v_logical_type VARCHAR2(30);
    v_description VARCHAR2(200);
    v_category VARCHAR2(20);
    v_ddl_clause VARCHAR2(100);
    v_ratio_min NUMBER;
    v_ratio_max NUMBER;
BEGIN
    v_cursor := PKG_EXADATA_DETECTION.get_available_types;

    DBMS_OUTPUT.PUT_LINE(RPAD('Type', 15) || ' ' || RPAD('Category', 10) || ' ' ||
                        RPAD('DDL Clause', 30) || ' ' || RPAD('Ratio Range', 15));
    DBMS_OUTPUT.PUT_LINE(RPAD('-', 15, '-') || ' ' || RPAD('-', 10, '-') || ' ' ||
                        RPAD('-', 30, '-') || ' ' || RPAD('-', 15, '-'));

    LOOP
        FETCH v_cursor INTO v_logical_type, v_description, v_category, v_description,
                           v_ddl_clause, v_ratio_min, v_ratio_max, v_description,
                           v_description, v_description, v_description;
        EXIT WHEN v_cursor%NOTFOUND;

        DBMS_OUTPUT.PUT_LINE(RPAD(v_logical_type, 15) || ' ' ||
                            RPAD(v_category, 10) || ' ' ||
                            RPAD(v_ddl_clause, 30) || ' ' ||
                            v_ratio_min || ':1 - ' || v_ratio_max || ':1');
    END LOOP;

    CLOSE v_cursor;
END;
/

PROMPT
PROMPT ================================================================================
PROMPT Exadata Detection Package Created Successfully!
PROMPT ================================================================================
PROMPT
PROMPT Key Features:
PROMPT   - Automatic Exadata platform detection
PROMPT   - Multi-method detection (CELL_OFFLOAD_PROCESSING, V$CELL, GV$CELL_CONFIG)
PROMPT   - Platform-aware compression type mapping
PROMPT   - HCC compression on Exadata, BASIC/OLTP fallback on Standard
PROMPT   - Performance-optimized with package variable caching
PROMPT   - Comprehensive logging and debugging support
PROMPT
PROMPT Usage Examples:
PROMPT   -- Check if running on Exadata
PROMPT   SELECT CASE WHEN PKG_EXADATA_DETECTION.is_exadata
PROMPT          THEN 'Exadata' ELSE 'Standard' END AS platform FROM DUAL;
PROMPT
PROMPT   -- Get compression clause for platform
PROMPT   SELECT PKG_EXADATA_DETECTION.get_compression_clause('QUERY_LOW') FROM DUAL;
PROMPT
PROMPT   -- Verify platform detection
PROMPT   EXEC PKG_EXADATA_DETECTION.verify_platform;
PROMPT
PROMPT   -- Refresh detection (clears cache)
PROMPT   EXEC PKG_EXADATA_DETECTION.refresh_detection;
PROMPT
PROMPT ================================================================================

SET ECHO OFF
